<!DOCTYPE html>
<meta charset="utf-8">
<svg width="500" height="500"></svg>
<canvas width="500" height="500"></canvas>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

const n = 1000;
// a, b scope
const a_min = -0.5;
const a_max = 0.5;

const b_min = -1.1;
const b_max = 1.1;

const x0 = 0.1;
const y0 = 0.8;

const fixed_radius = 5; // for .n_plots
const xy_radius = 12.2;
const xmin = -6.2;
const xmax = xmin + xy_radius;
const ymin = -6.2;
const ymax = ymin + xy_radius;



let canvas = d3.select("canvas"),
    context = canvas.node().getContext("2d"),
    width = canvas.property("width"),
    height = canvas.property("height"),
    radius = 1.2;

// var points = d3.range(2000).map(phyllotaxis(10));
// var points = henon_map(0.285, 0.999, x0, y0, n);
// let hmap = new Array(n).fill([0, 0]); // [[x0, y0], [x1, y1], ... [xn, yn]]
let henon_math = new Array(n).fill([0, 0]); // [[x0, y0], [x1, y1], ... [xn, yn]] // math numbers, not pixels
let henon_draw = new Array(n).fill([0, 0]); // [[x0, y0], [x1, y1], ... [xn, yn]] // pixels positions

function henon_map(a, b, x0, y0, n) {
    henon_math[0] = [x0, y0];
    for (let i = 1; i < n; i++) {
      henon_math[i] = [1 - a * Math.pow(henon_math[i - 1][0], 2) + henon_math[i - 1][1], b * henon_math[i - 1][0]]

      // prevent infinity, TODO: try del
      if (Math.abs(henon_math[i][0]) > 1e6 || Math.abs(henon_math[i][1]) > 1e6) { 
        henon_math[i] = [0, 0]; 
      }
    }
}

// scales
let a_scale = d3.scaleLinear()
  .domain([a_min, a_max])
  .range([0, width])

let b_scale = d3.scaleLinear()
  .domain([b_min, b_max])
  .range([width, 0])

// scales 
let xy_plot_xScale = d3.scaleLinear()
  .domain([xmin, xmax]) // the range of the values to plot
  // .range([ 2*margin, width_unit - 2 *margin]); // the pixel range of the x-axis
  .range([0, width]); // the pixel range of the x-axis
let xy_plot_yScale = d3.scaleLinear()
  .domain([ymin, ymax])
  // .range([ width_unit - margin, margin ]);
  .range([ width, 0 ]);

canvas.call(d3.zoom()
  .scaleExtent([1 / 16, 10])
  .on("zoom", zoomed));

let global_transform = d3.zoomIdentity;
henon_map((a_min + a_max) / 2, -1.01, x0, y0, n); // change henon_math with a,b coefficiens from mouse
// henon_math
// draw_after_pan_zoom(global_transform); // this needs for first time?
draw_after_mousemove();

d3.select('svg')
  .on("mousemove", mouse_mooved);

function draw_after_mousemove() {
  context.beginPath();
  henon_draw = henon_math.map(point => [xy_plot_xScale(point[0]), xy_plot_yScale(point[1])]); // math to pixels
  draw_after_pan_zoom(global_transform);
  context.fill();
}

function mouse_mooved() {
  let mouse = d3.mouse(this);
  henon_map(a_scale.invert(mouse[0]), b_scale.invert(mouse[1]), x0, y0, n); // change henon_math with a,b coefficiens from mouse
  context.clearRect(0, 0, width, height); // try del this line for fun!
  draw_after_mousemove();
}

function draw_after_pan_zoom(transform) {
  context.beginPath();
  henon_draw.map(transform.apply, transform).forEach(drawPoint);
  context.fill();
}

function zoomed() {
  context.clearRect(0, 0, width, height);
  draw_after_pan_zoom(d3.event.transform);
  global_transform = d3.event.transform; // maybe pass this as argument somehow?
}

function drawPoint(point) {
  context.moveTo(point[0] + radius, point[1]);
  context.arc(point[0], point[1], radius, 0, 2 * Math.PI);
}


</script>
<style>
svg {
  background-color: tomato;
}
canvas {
  background-color: #eaf2ff;
}
</style>
