<!DOCTYPE html>
<meta charset="utf-8">
<svg width="500" height="500"></svg>
<canvas width="500" height="500"></canvas>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

const n = 1000;
// a, b scope
const a_min = -0.5;
const a_max = 0.5;

const b_min = -1.1;
const b_max = 1.1;

const x0 = 0.1;
const y0 = 0.8;

const fixed_radius = 5; // for .n_plots
const xy_radius = 12.2;
const xmin = -6.2;
const xmax = xmin + xy_radius;
const ymin = -6.2;
const ymax = ymin + xy_radius;


var canvas = d3.select("canvas"),
    context = canvas.node().getContext("2d"),
    width = canvas.property("width"),
    height = canvas.property("height"),
    radius = 1.;

// var points = d3.range(2000).map(phyllotaxis(10));
// var points = henon_map(0.285, 0.999, x0, y0, n);
let hmap = new Array(n).fill([0, 0]); // [[x0, y0], [x1, y1], ... [xn, yn]]

// scales
let a_scale = d3.scaleLinear()
    .domain([a_min, a_max])
    .range([0, width])

let b_scale = d3.scaleLinear()
    .domain([b_min, b_max])
    .range([width, 0])

// scales 
let xy_plot_xScale = d3.scaleLinear()
    .domain([xmin, xmax]) // the range of the values to plot
    // .range([ 2*margin, width_unit - 2 *margin]); // the pixel range of the x-axis
    .range([0, width]); // the pixel range of the x-axis
let xy_plot_yScale = d3.scaleLinear()
    .domain([ymin, ymax])
    // .range([ width_unit - margin, margin ]);
    .range([ width, 0 ]);

canvas.call(d3.zoom()
    .scaleExtent([1 / 32, 1000])
    .on("zoom", zoomed));

// drawPoints();

drawPoints(d3.zoomIdentity);

// function zoomed() {
//   context.clearRect(0, 0, width, height);
//   drawPoints(d3.event.transform);
// }

function zoomed() {
  // context.save();
  context.clearRect(0, 0, width, height);
  // context.translate(d3.event.transform.x, d3.event.transform.y);
  // context.scale(d3.event.transform.k, d3.event.transform.k);
  // drawPoints();
  drawPoints(d3.event.transform);
  // context.restore();
}

// function drawPoints() {
//   context.beginPath();
//   hmap.forEach(drawPoint);
//   context.fill();
// }

function drawPoints(transform) {
  context.beginPath();
  // hmap.map(rescale);
  hmap.map(transform.apply, transform).forEach(drawPoint);
  context.fill();
}


function drawPoints2() {
  context.beginPath();
  // hmap.map(rescale).forEach(drawPoint);
  hmap.map(point => [xy_plot_xScale(point[0]), xy_plot_yScale(point[1])]).forEach(drawPoint);
  hmap.forEach(drawPoint);
  context.fill();
}

function rescale(point) {
  return [xy_plot_xScale(point[0]), xy_plot_yScale(point[1])];
}

function drawPoint(point) {
  context.moveTo(point[0] + radius, point[1]);
  context.arc(point[0], point[1], radius, 0, 2 * Math.PI);
}

function henon_map(a, b, x0, y0, n) {
    hmap[0] = [x0, y0];
    for (let i = 1; i < n; i++) {
      hmap[i] = [1 - a * Math.pow(hmap[i - 1][0], 2) + hmap[i - 1][1], b * hmap[i - 1][0]]

      // prevent infinity, TODO: try del
      if (Math.abs(hmap[i][0]) > 1e6 || Math.abs(hmap[i][1]) > 1e6) { 
          hmap[i] = [0, 0]; 
      }
    }
    // points = hmap;
    // return hmap;
}

d3.select('svg')
  .on("mousemove", mouse_mooved);

function mouse_mooved() {
  let mouse = d3.mouse(this);
  // let mouse_unzoomed = d3.mouse(d3.select("svg").node());
  // red_pointer.attr("cx", mouse[0]).attr("cy", mouse[1]);
  // red_pointer.attr("cx", mouse_unzoomed[0]).attr("cy", mouse_unzoomed[1]);
  // red_pointer.attr("cx", d3.event.pageX).attr("cy", d3.event.pageY);
  henon_map(a_scale.invert(mouse[0]), b_scale.invert(mouse[1]), x0, y0, n); // right values, works well
  // context.save();
  context.clearRect(0, 0, width, height); // try del this line for fun!
  drawPoints2();
  // context.restore();
  // redraw();
}


</script>
<style>
svg {
  background-color: tomato;
}
canvas {
  background-color: #eaf2ff;
}
</style>
